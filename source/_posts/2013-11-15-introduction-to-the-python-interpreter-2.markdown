---
layout: post
title: "Introduction to the Python Interpreter, Part 2: Code Objects"
date: 2013-11-15 19:22
comments: false
categories: python, python-internals
---

This is part of a [series](/blog/categories/python-internals) on the python interpreter.
Part 1 [here](/blog/2013/11/15/introduction-to-the-python-interpreter/).

When we left our heroes, they were examining a simple function object.  Let's now dive a level deeper, and look at this function's code object.

``` python
>>> def foo(a):
...     x = 3
...     return x + a
... 
>>> foo
<function foo at 0x107ef7aa0>
>>> foo.func_code
<code object foo at 0x107eeccb0, file "<stdin>", line 1>
```

As you can see in the code above, the code object is an attribute of the function object.  (There are lots of other attributes on the function object, too. They're mostly not interesting because `foo` is so simple.)

A code object is generated by the Python compiler and intepreted by the interpreter.  It contains information that this interpreter needs to do its job. Let's look at the attributes of the code object.

``` python 
>>> dir(foo.func_code)
['__class__', '__cmp__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', 
'__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', '__new__', 
'__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', 
'__subclasshook__', 'co_argcount', 'co_cellvars', 'co_code', 'co_consts', 'co_filename', 
'co_firstlineno', 'co_flags', 'co_freevars', 'co_lnotab', 'co_name', 'co_names', 'co_nlocals', 
'co_stacksize', 'co_varnames']
```

There's a bunch of stuff going on here, much of which we're not going to worry about today.  Let's take a look at three attributes that are interesting to us for our code object on `foo`.

``` python
>>> foo.func_code.co_varnames
('a', 'x')
>>> foo.func_code.co_consts
(None, 3)
>>> foo.func_code.co_argcount
1
```

Here are some intelligible-looking things: the names of the variables and the constants that our function knows about and the number of arguments the function takes.  But so far, we haven't seen anything that looks like instructions for how to execute the code object.  These instructions are called _bytecode_.  Bytecode is an attribute of the code object:

```python 
>>> foo.func_code.co_code
'd\x01\x00}\x01\x00|\x01\x00|\x00\x00\x17S'
```

So much for our intelligible-looking things.  What's going on here?  We'll dive in to bytecode in Part 3.
