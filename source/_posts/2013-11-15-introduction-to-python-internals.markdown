---
layout: post
title: "Introduction to the Python Interpreter, Part 2: Code Objects"
date: 2013-11-15 16:04
comments: true
categories: 
---

This is part of a [series](/blog/categories/python-internals) on python internals.
[Part 1](/blog/2013/11/15/introduction-to-the-python-interpreter/)

When we left our heroes, they were examining a simple function object.  Let's now dive a level deeper, and look at this function's code object.

``` python
``` python
>>> def foo(a):
...     x = 3
...     return x + a
... 
>>> foo
<function foo at 0x107ef7aa0>
>>> foo.func_code
<code object foo at 0x107eeccb0, file "<stdin>", line 1>
```

As you can see in the code above, the code object is an attribute of the function object.  (There are lots of other attributes on the function object, too. They're mostly not interesting because `foo` is so simple.)

A code object is generated by the Python compiler and intepreted by the interpreter.  It contains information that this interpreter needs to do its job. Let's look at the attributes of the code object.

``` python 
>>> dir(foo.func_code)
['__class__', '__cmp__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'co_argcount', 'co_cellvars', 'co_code', 'co_consts', 'co_filename', 'co_firstlineno', 'co_flags', 'co_freevars', 'co_lnotab', 'co_name', 'co_names', 'co_nlocals', 'co_stacksize', 'co_varnames']
```

There's a bunch of stuff going on here, much of which we're not going to worry about today.  Let's take a look at three attributes that are interesting to us for our code object on `foo`.

``` python
>>> foo.func_code.co_varnames
('a', 'x')
>>> foo.func_code.co_consts
(None, 3)
>>> foo.func_code.co_argcount
1
```

Here are some intelligible-looking things: the names of the variables and the constants that our function knows about and the number of arguments the function takes.  But so far, we haven't seen anything that looks like instructions for how to execute the code object.  These instructions are called _bytecode_.  Bytecode is an attribute of the code object:

```python 
>>> foo.func_code.co_code
'd\x01\x00}\x01\x00|\x01\x00|\x00\x00\x17S'
```

So much for our intelligible-looking things.  What's going on here?  We'll dive in to bytecode in Part 3.

### Bytecode

Those instructions - called bytecode - are found in the `co_code` attribute.

``` python
>>> foo.func_code.co_code
'd\x01\x00}\x01\x00|\x01\x00|\x00\x00\x17S'
```

This looks utterly mystifying at first.  Let's dig in.

To start, notice that "python bytecode" and "a python code object" are not the same thing: the bytecode is an attribute of the code object, among many other attributes.  This will be important momentarily.

So what's bytecode?  Well, it's just a series of bytes.  They look wacky when we print them because some of them are printable and others aren't, so let's take the `ord` of each byte to see that they're just numbers.

``` python
>>> [ord(b) for b in foo.func_code.co_code]
[100, 1, 0, 125, 1, 0, 124, 1, 0, 124, 0, 0, 23, 83]
```

Here are the bytes that make up python bytecode.  Each byte means something to the interpreter.  The interpreter will loop through each byte, look up what it should do for each one, and then do that thing.

One way to understand python bytecode would be to find the CPython interpreter file (it's `ceval.c`), and flip through it looking up what `100` means, then `1`, then `0`, and so on.  Luckily, there's a better way: the `dis` module.

Before we get there, though, notice what we don't see: any kind of python object.  It's just numbers.

### Disassembling bytecode

Disassembling bytecode just means taking this series of numbers and printing out something we humans can understand.

The function `dis.dis` analyzes a code object to do exactly that.  Let's take a look.  (As a reminder, here's `foo` again.)

``` python
>>> def foo(a):
...     x = 3
...     return x + a
... 
>>> dis.dis(foo.func_code)
  2           0 LOAD_CONST               1 (3)
              3 STORE_FAST               1 (x)

  3           6 LOAD_FAST                1 (x)
              9 LOAD_FAST                0 (a)
             12 BINARY_ADD          
             13 RETURN_VALUE
```

You usually see this called as `dis.dis(foo)` - that is, directly on the function object.  That's just a convenience: `dis` is really analyzing the code object.  If it's passed a function, it just gets its code object.

The numbers in the left-hand column are line numbers.  The second column is the offset into the bytecode: that is, `LOAD_CONST` appears at position 0, `STORE_FAST` at position 3, and so on.  The middle column shows the names of bytes. These names are just for our (human) benefit - the interpreter doesn't need the names.  The fourth column is an offset into other attributes of the code object: `co_consts` on the first line, and `co_varnames` on the second line.  Finally, in the fifth column, `dis` has looked up the constants or names in the place the fourth column specified, and tells us what it found there.

People - among them `dis` module's docs - often talk about `dis` as a disassembler of python bytecode.  `dis` does this, but it knows about more than just the bytecode, too: it uses the whole code object to give us an understandable printout.  The middle three columns show information actually encoded in the bytecode, while the first and the last columns show other information.

Why is the second instruction, `STORE_FAST`, at bytecode position 3?  The offsets seem to count up by three, but just when we think we have the pattern, the last byte, `RETURN_VALUE`, is only one step later than the one before it. The thing that's going on here is that some bytecodes have arguments, and others don't.  When we're trying to load a variable name, we need to know what name to load.  (You may be wondering why BINARY_ADD doesn't need arguments, too.  We'll come back to that soon.)  If a bytecode has an argument, the next two bytes are the index into a list on the code object.

How do we get from bytes like `100` to names like `LOAD_CONST` and back?  Try to think of a way you'd do it.  If you thought "Uh, well, you could have a list that has the byte names in the right order," or you thought, "Um, I guess you could have a dictionary where the names are the keys and the byte values are the values," then congratulations!  That's exactly what's going on.  The file `opcode.py` defines the list and the dictionary.  It's full of lines like this one (`def_op` inserts the mapping in both the list and the dictionary):

``` python
def_op('LOAD_CONST', 100)       # Index in const list
```

Looking back at the definition of LOAD_CONST above, there's even a friendly comment telling us what this byte's argument means: it's an index into the code object's list of constants, which for us is `foo.func_code.co_consts`. In the first line of our disassembled output, `dis` has looked up index `1` in `foo.func_code.co_consts` and found `3`.

### Interpreting bytecode

Looking at the output of `dis` and examining the code object has taught us an important thing: _bytecode by itself isn't enough information to execute python code._ To drive this home, let's write another simple function.  Then we'll look at the function's code object's bytecode, with and without the help of `dis`.

``` python
>>> def modulus(x, y):
...     return x % y
... 
>>> dis.dis(modulus.func_code)
  2           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 BINARY_MODULO       
              7 RETURN_VALUE
>>> [ord(b) for b in modulus.func_code.co_code]
[124, 0, 0, 124, 1, 0, 22, 83]
```

It seems really clear what this function does: it takes two arguments, which are probably numbers, and returns the remainder from dividing the first by the second - the modulus.

```python
>>> modulus(15,4)
3
```

So far, so good.  But what if we don't pass it numbers?

``` python
>>> modulus("hello %s", "world")
'hello world'
```

Uh-oh, what happened there?  You've probably seen this before, but it usually looks like this: 

``` python
>>> print "hello %s" % "world"
hello world
```

If you want to use the `%` symbol to do something with strings, all you need to do is define what it means to call `str.__mod__`!  In Python, mod-ing a string against another string (or a tuple) does string interpolation.  Our function `mod` can calculate remainders, or it can do string formatting ... or it can do anything else!  If we've defined a custom object that responds to `__mod__`, then we can do _anything_.

``` python
>>> class Surprise(object):
...     def __init__(self, num):
...         self.num = num
...     def __mod__(self, other):
...         return self.num + other.num
... 
>>> seven = Surprise(7)
>>> four = Surprise(4)
>>> modulus(seven, four)
11
```

When the compiler built our code object for `mod`, it had no idea what would end up happening.  It just emitted some instructions: load one name, load another, `BINARY_MODULO` the two of them, and return the result.

If we knew what `x` and `y` were going to be

This is one of the reasons that it's hard to optimize Python: you don't know when you're compiling the code object what it's going to end up doing.

