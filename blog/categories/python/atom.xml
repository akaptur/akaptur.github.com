<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Of Interest]]></title>
  <link href="http://akaptur.github.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://akaptur.github.com/"/>
  <updated>2013-10-31T17:34:31-04:00</updated>
  <id>http://akaptur.github.com/</id>
  <author>
    <name><![CDATA[akaptur]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Bytecode: Fun with dis]]></title>
    <link href="http://akaptur.github.com/blog/2013/08/14/python-bytecode-fun-with-dis/"/>
    <updated>2013-08-14T16:04:00-04:00</updated>
    <id>http://akaptur.github.com/blog/2013/08/14/python-bytecode-fun-with-dis</id>
    <content type="html"><![CDATA[<p>Last week at <a href="https://www.hackerschool.com/">Hacker School</a> I did a quick presentation on python bytecode and the <code>dis</code> module.  The disassembler is a very powerful tool with a gentle learning curve &ndash; that is, you can get a fair amount out of it without really knowing much about what&rsquo;s going on.  This post is a quick introduction to how and why you should use it.</p>

<h3>What&rsquo;s bytecode?</h3>

<p>Bytecode is the internal representation of a python program in the compiler.  Here, we&rsquo;ll be looking at bytecode from cpython, the default compiler.  If you don&rsquo;t know what compiler you&rsquo;re using, it&rsquo;s probably cpython.</p>

<h3>How do I get bytecode?</h3>

<p>You already have it!  Bytecode is what&rsquo;s contained in those .pyc files you see when you import a module.  It&rsquo;s also created on the fly by running any python code.</p>

<h3>Disassembling</h3>

<p>Ok, so you have some bytecode, and you want to understand it.  Let&rsquo;s look at it without using the <code>dis</code> module first.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>def foo():
&hellip;     a = 2
&hellip;     b = 3
&hellip;     return a + b
&hellip;
foo.func_code
<code object foo at 0x106353530, file "<stdin>&ldquo;, line 1>
foo.func_code.co_code
&rsquo;d\x01\x00}\x00\x00d\x02\x00}\x01\x00|\x00\x00|\x01\x00\x17S'
print [ord(x) for x in foo.func_code.co_code]
[100, 1, 0, 125, 0, 0, 100, 2, 0, 125, 1, 0, 124, 0, 0, 124, 1, 0, 23, 83]
```</p></blockquote></blockquote></blockquote>

<p>Hmm, that was &hellip; not very enlightening.  We can see that we have a bunch of bytes (some printable, others not), but we have no idea what they mean.</p>

<p>Let&rsquo;s run it through <code>dis.dis</code> instead.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>import dis
dis.dis(foo)
  2           0 LOAD_CONST               1 (2)</p>

<pre><code>          3 STORE_FAST               0 (a)
</code></pre></blockquote></blockquote></blockquote>

<p>  3           6 LOAD_CONST               2 (3)</p>

<pre><code>          9 STORE_FAST               1 (b)
</code></pre>

<p>  4          12 LOAD_FAST                0 (a)</p>

<pre><code>         15 LOAD_FAST                1 (b)
         18 BINARY_ADD          
         19 RETURN_VALUE  
</code></pre>

<p>```</p>

<p>Now this starts to make some sense.  <code>dis</code> takes each byte, finds the opcode that corresponds to it in <code>opcodes.py</code>, and prints it as a nice, readable constant.  If we look at <code>opcodes.py</code> we see that <code>LOAD_CONST</code> is 100, <code>STORE_FAST</code> is 125, etc. <code>dis</code> also shows the line numbers on the left and the values or names on the right.  So without ever seeing something like before, we have an idea what&rsquo;s going on: we first load a constant, 2, then somehow store it as <code>a</code>.  Then we repeat this with 3 and <code>b</code>.  We load <code>a</code> and <code>b</code> back up, do <code>BINARY_ADD</code>, which presumably adds the numbers, and then do <code>RETURN_VALUE</code>.</p>

<p>Examining the bytecode can sometimes increase your understanding of python code.  Here is one example.</p>

<h3>elif</h3>

<p><code>elif</code> is identical in bytecode to <code>else ... if</code>.  Take a look:</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>def flat(num):
&hellip;     if num % 3 == 0:
&hellip;         print &ldquo;Fizz&rdquo;
&hellip;     elif num % 5 == 0:
&hellip;         print &ldquo;Buzz&rdquo;
&hellip;     else:
&hellip;         print num</p>

<p>def nested(num):
&hellip;     if num % 3 == 0:
&hellip;         print &ldquo;Fizz&rdquo;
&hellip;     else:
&hellip;         if num % 5 == 0:
&hellip;             print &ldquo;Buzz&rdquo;
&hellip;         else:
&hellip;             print num
```</p></blockquote></blockquote></blockquote>

<p>We&rsquo;ve read <a href="http://www.python.org/dev/peps/pep-0008/">PEP 8</a> so we know that <em>flat is better than nested</em> for style and readability.  But is there a performance difference?  Not at all &ndash; in fact, these two functions have identical bytecode.</p>

<p>```
  2           0 LOAD_FAST                0 (num)</p>

<pre><code>          3 LOAD_CONST               1 (3)
          6 BINARY_MODULO       
          7 LOAD_CONST               2 (0)
         10 COMPARE_OP               2 (==)
         13 POP_JUMP_IF_FALSE       24
</code></pre>

<p>  3          16 LOAD_CONST               3 (&lsquo;Fizz&rsquo;)</p>

<pre><code>         19 PRINT_ITEM          
         20 PRINT_NEWLINE       
         21 JUMP_FORWARD            29 (to 53)
</code></pre>

<p>  4     >>   24 LOAD_FAST                0 (num)</p>

<pre><code>         27 LOAD_CONST               4 (5)
         30 BINARY_MODULO       
         31 LOAD_CONST               2 (0)
         34 COMPARE_OP               2 (==)
         37 POP_JUMP_IF_FALSE       48
</code></pre>

<p>  5          40 LOAD_CONST               5 (&lsquo;Buzz&rsquo;)</p>

<pre><code>         43 PRINT_ITEM          
         44 PRINT_NEWLINE       
         45 JUMP_FORWARD             5 (to 53)
</code></pre>

<p>  7     >>   48 LOAD_FAST                0 (num)</p>

<pre><code>         51 PRINT_ITEM          
         52 PRINT_NEWLINE       
    &gt;&gt;   53 LOAD_CONST               0 (None)
         56 RETURN_VALUE    
</code></pre>

<p>```</p>

<p>That makes sense &ndash; <code>else</code> just means &ldquo;start executing here if the <code>if</code> was false&rdquo; &ndash; there&rsquo;s no more computation to do.  <code>elif</code> is just <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar</a>.</p>

<h3>Further reading:</h3>

<p>This just scratches the surface of what&rsquo;s interesting about python bytecode.</p>

<p>If you enjoyed this, you might enjoy diving into Yaniv Aknin&rsquo;s <a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">series</a> on python internals.  If you&rsquo;re excited about bytecode, you should contribute to Ned Batchelder&rsquo;s <a href="https://github.com/nedbat/byterun">byterun</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Systematic Debugging]]></title>
    <link href="http://akaptur.github.com/blog/2013/07/24/systematic-debugging/"/>
    <updated>2013-07-24T13:54:00-04:00</updated>
    <id>http://akaptur.github.com/blog/2013/07/24/systematic-debugging</id>
    <content type="html"><![CDATA[<p>We&rsquo;ve asked many of our residents at Hacker School what qualities all great programmers share.  There&rsquo;s very little agreement &ndash; clearly, there are a multitude of ways to be a great programmer, and you can think of a counter-example for almost every quality you can name.  One of the rare non-controversial statements came first from Jessica McKellar, who identified systematic debugging as a key skill.</p>

<p>What does systematic debugging look like?  At this point, I&rsquo;m focused on two aspects: asking a clear question, and keeping track of my mental &ldquo;stack&rdquo;.  I had a particularly fun and interesting bug yesterday that I think illustrates this nicely.</p>

<p>The problem at hand was a brainteaser from Jessica:</p>

<blockquote><p>Using the official SOWPODS Scrabble dictionary, what letters, if any, never appear doubled? (By that I mean &mdash; &ldquo;AA&rdquo; does appear doubled because it is in &ldquo;AARDVARK&rdquo;, &ldquo;BB&rdquo; does appear doubled because it is in &ldquo;BUBBLE&rdquo; &mdash; are there any letters that never appear doubled in a word?)</p></blockquote>

<p>I came up with a solution, but it was kind of slow, so I was trying to find a faster one.  Also, my original solution used a regular expression to match a doubled letter in a word, but it would only find the first pair (e.g. in BOOKKEEPER only the &lsquo;OO&rsquo; would be caught).</p>

<p>I decided to try taking the dictionary as a single string, rather than a list of words, and consuming it one letter-pair at a time, as follows.</p>

<p>``` python
def find_all_doubles_as_word_mash():</p>

<pre><code>words = open('sowpods.txt').read()
letters = set(string.uppercase)
dub_re = re.compile(r"([A-Z])(\1)")
end = 0
dubbed = re.search(dub_re, words[end:])

while dubbed and letters:
    letters -= set(dubbed.group())
    end += dubbed.end()
    dubbed = re.search(dub_re, words[end:])
    print end, '/', len(words)

return letters
</code></pre>

<p>```</p>

<p>If you&rsquo;re thinking, &ldquo;Hmm, that looks like it might be slow,&rdquo; congratulations!  It is indeed quite slow.  I had two guesses for why it was slow. (It wasn&rsquo;t the print statement.)  First, maybe I was copying the string over and over, and that was slowing down the function.  Second, maybe I misunderstodd the regular expression &ndash; for example, maybe it was taking a longer time to operate on a longer string. I decided to investigate the second possibility first, since regular expressions were more of a mystery to me.</p>

<p>At this point in the problem solving, my mental stack looks something like this:</p>

<pre>
 ---------------------------
| regex taking longer on a  | (newest)
| longer-length string?     |
 ---------------------------
| reg exp? or string copy?  |
 ---------------------------
| function is so slow, why? |
 ---------------------------
|   find a faster solution  |
 ---------------------------
|  solve wordplay problem   | (oldest)
 ---------------------------
</pre>


<p>The next step was to test my theory that my regular expression should not take longer on a longer string.  Importantly, the regex had no &ldquo;greedy&rdquo; elements &ndash; it should match and return the first time it encounters two identical characters, regardless of how long the string is after those matching characters.  Here was the experiment I wrote:</p>

<p>``` python test_with_timeit.py
import timeit</p>

<p>SETUP = &ldquo;&rdquo;&ldquo;import re;
import string;
double = re.compile(r&rdquo;([a-z])(\1)&ldquo;);
short_test = "hee&rdquo; + string.lowercase;
long_test = &ldquo;hee&rdquo; + string.lowercase*100
&ldquo;&rdquo;"</p>

<p>N_TIMES = 10000</p>

<p>def test():</p>

<pre><code>short_time = timeit.timeit(stmt="double.search(short_test)", setup=SETUP, number=N_TIMES)
long_time = timeit.timeit(stmt="double.search(long_test)", setup=SETUP, number=N_TIMES)

print "short:", short_time
print "long:", long_time
print "time ratios:", long_time / short_time, "x"
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>test()
</code></pre>

<p><code>
In both cases, I thought, the regex should check "he", fail, check "ee", succeed, and return.  To my great surprise, the long string test took 70-80x as long to run as the short string test!  
</code> text test_with_timeit output
short: 0.0243809223175
long: 1.77788496017
time ratios: 72.9211527366 x
```</p>

<p>Clearly, I was missing something about regular expressions.  I googled around and learned some details about backreferences, the <code>(\1)</code> in my code (which makes my regular expression not actually <a href="http://en.wikipedia.org/wiki/Regular_expression#Formal_language_theory">&ldquo;regular&rdquo;</a>), but that wasn&rsquo;t very illuminating.  (You can picture &ldquo;something about Finite State Automata&rdquo; being pushed onto and quickly popped back off the stack.)</p>

<p>My next step was to run timing experiments with a variety of regular expressions to see if I could find an element that made the difference.  At this point yesterday, I was still trying to pass strings to <code>timeit</code>, which was getting unwieldy.  (Stay tuned to learn two better ways to do timing.)  I switched to a simpler timing script, just taking <code>time.time()</code> at the start and end of the algorithm.</p>

<p>``` python test_without_timeit.py
import re
import string
import time
from collections import defaultdict</p>

<p>everybody_stand_back = {</p>

<pre><code>"double" : re.compile(r"([a-z])(\1)"),
"double_var" : re.compile(r"([a-z])\1"),
"single" : re.compile(r"([a-z])"),
"verbose" : re.compile("|".join(let*2 for let in string.lowercase)),
</code></pre>

<p>}</p>

<p>test_strings = {</p>

<pre><code>"short" : "hee",
"long" : "hee" + string.lowercase*100,
</code></pre>

<p>}</p>

<p>outcomes = defaultdict(dict)</p>

<p>N_TIMES = 100000</p>

<p>def test():</p>

<pre><code>for name, regex in everybody_stand_back.iteritems():
    for string_name, test_string in test_strings.iteritems():
        start = time.time()
        for _ in range(N_TIMES):
            re.search(regex, test_string)
        end = time.time()
        delta = end - start
        outcomes[name][string_name] = delta

return outcomes
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>outcomes = test()
for name, regex in outcomes.iteritems():
    print name, regex["long"]/regex["short"]
</code></pre>

<p>```</p>

<p>Hopefully the differences would start to become clear, and I could easily extend this to add more variations on the regular expression.</p>

<p>It printed:
<code>
double 0.953508019384
single 1.15989795352
double_var 1.04188410251
verbose 0.861312402506
</code></p>

<p>Uh-oh, wait a minute, I thought this was identical code.  Where did the 70x time difference go?</p>

<p>I couldn&rsquo;t see any obvious errors, so I went back to the <code>timeit</code> code.  Could I reproduce these results while still using the <code>timeit</code> module?</p>

<p>Let&rsquo;s look back at the problem stack.</p>

<pre>
 ---------------------------
| what's up with timeit?    |    
 ---------------------------
| is this code different?   |    
 ---------------------------
| timing programs give      |
| different results, uh-oh  |
 ---------------------------
| regex taking longer on a  |
| longer-length string      |
 ---------------------------
| reg exp? or string copy?  |
 ---------------------------
| function is so slow, why? |
 ---------------------------
|   find a faster solution  |
 ---------------------------
|  solve wordplay problem   | (oldest)
 ---------------------------
</pre>


<p>At this point <a href="https://twitter.com/brandon_rhodes">Brandon Rhodes</a> joined me in pair-debugging, and we made a couple of discoveries.  The most interesting of these was that two different ways of calling timeit generated wildly different results.</p>

<p>``` python test_with_timeit.py
import re
import timeit
import string</p>

<p>double = re.compile(r"([a-z])(\1)&ldquo;)</p>

<p>SETUP = &ldquo;&rdquo;&ldquo;import re;
import string;
double = re.compile(r&rdquo;([a-z])(\1)&ldquo;);
short_test = "hee&rdquo; + string.lowercase;
long_test = &ldquo;hee&rdquo; + string.lowercase*200
&ldquo;&rdquo;"</p>

<p>N_TIMES = 10000</p>

<p>short_test = &ldquo;hee&rdquo; + string.lowercase
long_test = &ldquo;hee&rdquo; + string.lowercase*200</p>

<p>def test():</p>

<pre><code>short_time = timeit.timeit(stmt="double.search(short_test)", setup=SETUP, number=N_TIMES)
long_time = timeit.timeit(stmt="double.search(long_test)", setup=SETUP, number=N_TIMES)

print "short:", short_time
print "long:", long_time
</code></pre>

<p>def short_string_test():</p>

<pre><code>double.search(short_test)
</code></pre>

<p>def long_string_test():</p>

<pre><code>double.search(long_test)
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>print "method 1: strings"
test()

print "method 2: functions"
print timeit.timeit(short_string_test, number=N_TIMES)
print timeit.timeit(long_string_test, number=N_TIMES)

print "method 3: build timer explicitly"
s = timeit.Timer(stmt="double.search(long_test)", setup=SETUP)
print "short:", s.timeit(number=N_TIMES)
t = timeit.Timer(stmt="double.search(long_test)", setup=SETUP)
print "long:", t.timeit(number=N_TIMES)
</code></pre>

<p>```</p>

<p><code>python test_with_timeit output
method 1: strings
short: 0.0235750675201
long: 3.41090488434
method 2: functions
0.0102179050446
0.00959801673889
method 3: build timer explicitly
short: 0.0263011455536
long: 3.42960190773
</code>
So now we know something is up with passing strings to timeit.</p>

<pre>
 ---------------------------
| timeit string version - ? |        
 ---------------------------
| what's up with timeit?    |    
 ---------------------------
| is this code different?   |    
 ---------------------------
          ....
</pre>


<p>Ok, we&rsquo;ve narrowed it down this far &ndash; it&rsquo;s time to take a look at the source.  <code>timeit</code> is a module written in python (yay!), and the relevant parts look pretty straightforward:</p>

<p>``` python timeit.py
template = &ldquo;&rdquo;&ldquo;
def inner(<em>it, </em>timer):</p>

<pre><code>%(setup)s
_t0 = _timer()
for _i in _it:
    %(stmt)s
_t1 = _timer()
return _t1 - _t0
</code></pre>

<p>&ldquo;&rdquo;"</p>

<p>class Timer:</p>

<pre><code>"""Class for timing execution speed of small code snippets.

The constructor takes a statement to be timed, an additional
statement used for setup, and a timer function.  Both statements
default to 'pass'; the timer function is platform-dependent (see
module doc string).

To measure the execution time of the first statement, use the
timeit() method.  The repeat() method is a convenience to call
timeit() multiple times and return a list of results.

The statements may contain newlines, as long as they don't contain
multi-line string literals.
"""

def __init__(self, stmt="pass", setup="pass", timer=default_timer):
    """Constructor.  See class doc string."""
    self.timer = timer
    ns = {}
    if isinstance(stmt, basestring):
        stmt = reindent(stmt, 8)
        if isinstance(setup, basestring):
            setup = reindent(setup, 4)
            src = template % {'stmt': stmt, 'setup': setup}
        elif hasattr(setup, '__call__'):
            src = template % {'stmt': stmt, 'setup': '_setup()'}
            ns['_setup'] = setup
        else:
            raise ValueError("setup is neither a string nor callable")
        self.src = src # Save for traceback display
        code = compile(src, dummy_src_name, "exec")
        exec code in globals(), ns
        self.inner = ns["inner"]
    elif hasattr(stmt, '__call__'):
        self.src = None
        if isinstance(setup, basestring):
            _setup = setup
            def setup():
                exec _setup in globals(), ns
        elif not hasattr(setup, '__call__'):
            raise ValueError("setup is neither a string nor callable")
        self.inner = _template_func(setup, stmt)
    else:
        raise ValueError("stmt is neither a string nor callable")

def timeit(self, number=default_number):
    """Time 'number' executions of the main statement.

    To be precise, this executes the setup statement once, and
    then returns the time it takes to execute the main statement
    a number of times, as a float measured in seconds.  The
    argument is the number of times through the loop, defaulting
    to one million.  The main statement, the setup statement and
    the timer function to be used are passed to the constructor.
    """
    if itertools:
        it = itertools.repeat(None, number)
    else:
        it = [None] * number
    gcold = gc.isenabled()
    gc.disable()
    timing = self.inner(it, self.timer)
    if gcold:
        gc.enable()
    return timing
</code></pre>

<p>def timeit(stmt=&ldquo;pass&rdquo;, setup=&ldquo;pass&rdquo;, timer=default_timer,</p>

<pre><code>       number=default_number):
"""Convenience function to create Timer object and call timeit method."""
return Timer(stmt, setup, timer).timeit(number)
</code></pre>

<p>```</p>

<p>Let&rsquo;s trace the part that&rsquo;s giving us the long execution string.  We call the module-level function <code>timeit.timeit</code>, which creates a Timer object and returns the result of calling its <code>timeit</code> method.  No surprise that we got identical results between our method #1 and method #3 above.</p>

<p>The <code>Timer</code> object checks to see if you&rsquo;ve passed it strings or callables as its <code>stmt</code> and <code>setup</code> parameters.  In our case both are strings.  The <code>init</code> method splices the strings into the source code here:</p>

<p><code>
src = template % {'stmt': stmt, 'setup': setup}
</code></p>

<p>We can isolate this in the REPL if we want to be extra-sure of how it works:
```</p>

<blockquote><blockquote><blockquote><p>template = &ldquo;&rdquo;&ldquo;
&hellip; def inner(<em>it, </em>timer):
&hellip;     %(setup)s
&hellip;     <em>t0 = </em>timer()
&hellip;     for <em>i in </em>it:
&hellip;         %(stmt)s
&hellip;     <em>t1 = </em>timer()
&hellip;     return <em>t1 &ndash; </em>t0
&hellip; &rdquo;&ldquo;&rdquo;
stmt = &ldquo;pass&rdquo;
setup = &ldquo;print &lsquo;here we go&rsquo;&rdquo;
print template % {&lsquo;stmt&rsquo;: stmt, &lsquo;setup&rsquo;: setup}</p></blockquote></blockquote></blockquote>

<p>def inner(<em>it, </em>timer):</p>

<pre><code>print 'here we go'
_t0 = _timer()
for _i in _it:
    pass
_t1 = _timer()
return _t1 - _t0
</code></pre>

<p>```</p>

<p>Got it &ndash; simple, legal python code is generated. So where is our regular expression getting screwed up?  Let&rsquo;s take a look at the code generated in our actual test by inserting a print statement into the <code>timeit</code> module.  (First we&rsquo;ll copy the module over to our current working directory, to avoid modifying our actual standard library.)</p>

<p><code>
src = template % {'stmt': stmt, 'setup': setup}
print src
</code></p>

<p>And now calling <code>test_with_timeit.py</code> again, it prints:</p>

<p>``` python
def inner(<em>it, </em>timer):</p>

<pre><code>import re;
import string;
double = re.compile(r"([a-z])()");
short_test = "hee" + string.lowercase;
long_test = "hee" + string.lowercase*200

_t0 = _timer()
for _i in _it:
    double.search(short_test)
_t1 = _timer()
return _t1 - _t0
</code></pre>

<p>```</p>

<p>This looks mostly reasonable &hellip; but hey, wait, what happened to the regular expression?</p>

<p><code>python
double = re.compile(r"([a-z])()");
</code></p>

<p>That&rsquo;s not right!  Changing <code>print src</code> to <code>print repr(src)</code> gives us a better idea what&rsquo;s up &ndash; the relevant line is now:</p>

<p><code>python
double = re.compile(r"([a-z])(\x01)");
</code></p>

<p>And looking back at the <code>SETUP</code> string &hellip; uh-oh, this isn&rsquo;t a raw string, and it contains an escape character (<code>(\1)</code>).  We can tell we&rsquo;re in trouble immediately in the REPL:
``` python</p>

<blockquote><blockquote><blockquote><p>print &ldquo;\1&rdquo;</p>

<p>repr(&ldquo;\1&rdquo;)
&ldquo;&lsquo;\x01&rsquo;&rdquo;
```</p></blockquote></blockquote></blockquote>

<p>Why does this happen?  We can consult the <a href="http://docs.python.org/2/reference/lexical_analysis.html#string-literals">docs on string literals</a> to find out.  Unless you&rsquo;re working with a raw string (one prefixed with <code>r</code> or <code>R</code>), escape characters are interpreted the same way they are in C.  Our text, a backslash followed by a number, matches the pattern for an octal digit: a backslash followed by 1-3 integers. <code>\ooo</code> indicates a character with the octal value <code>ooo</code>.  And that&rsquo;s exactly what we&rsquo;ve done:</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>ord(&ldquo;\1&rdquo;)
1
chr(1)
&lsquo;\x01&rsquo;
```</p></blockquote></blockquote></blockquote>

<p><code>\x01</code> is a legal (though unprintable) character, and <strong>it doesn&rsquo;t appear in our long string to test the regular expression.</strong> So <em>of course</em> the longer one took a longer time &ndash; it had to traverse the entire string looking for <code>\x01</code>, which it never found.</p>

<p>The fix is quite easy &ndash; one character, in fact.  Make the <code>SETUP</code> string raw:
<code>python
SETUP = r"""import re;
import string;
double = re.compile(r"([a-z])(\1)");
short_test = "hee" + string.lowercase;
long_test = "hee" + string.lowercase*200
"""
</code></p>

<p>&hellip; and the problem is solved.  So we can pop a bunch of frame off our problem stack and go investigate the string copying, which is in fact the issue.</p>

<pre>
 ---------------------------
| reg exp? or string copy?  |
 ---------------------------
| function is so slow, why? |
 ---------------------------
|   find a faster solution  |
 ---------------------------
|  solve wordplay problem   | (oldest)
 ---------------------------
</pre>


<h2>Lessons learned</h2>

<p>Interesting bugs are a ton of fun!  Now for a bit of introspection: what could have gone better?</p>

<ul>
<li><p>Most obviously, I could have spent less time on the regular-expression branch of why the function was slow, especially as the stack grew.  Whether I should have done this depends on your perspective: at Hacker School, I&rsquo;m almost 100% learning motivated and about 0% get-it-done motivated, so my time to solve the bug is virtually unbounded.</p></li>
<li><p>I was slightly overconfident about understanding how the <code>timeit</code> code splicing happened.  The code looked so simple that I didn&rsquo;t bother to check my understanding at first.</p></li>
<li><p>Passing <code>timeit.timeit</code> strings is an unwieldy way of doing timing.  I should have been using either the callable option, or just timing with <code>time python test_file.py</code> from the command line.  Both of these would have been easier to work with and would have sidestepped the bug.</p></li>
<li><p>My mental model of regular expressions was largely correct.  That&rsquo;s satisfying.</p></li>
<li><p>Strings!  Ouch.  This may not seem like much of a lesson, but it&rsquo;s useful to add to my mental list of Places That Bugs Lurk.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More side effecting]]></title>
    <link href="http://akaptur.github.com/blog/2013/07/02/more-side-effecting/"/>
    <updated>2013-07-02T15:47:00-04:00</updated>
    <id>http://akaptur.github.com/blog/2013/07/02/more-side-effecting</id>
    <content type="html"><![CDATA[<p><a href="https://twitter.com/ncoghlan_dev">Nick Coghlan</a> added another interesting note in response to my last post about creating side-effecting assignments in python.  Here&rsquo;s Nick:</p>

<blockquote class="twitter-tweet" data-conversation="none" data-cards="hidden"><p><a href="https://twitter.com/brandon_rhodes">@brandon_rhodes</a> <a href="https://twitter.com/akaptur">@akaptur</a> You can do better if you&#39;re the one controlling the namespace creation (e.g. an importer): <a href="https://t.co/gA8LD121cD">https://t.co/gA8LD121cD</a></p>&mdash; Nick Coghlan (@ncoghlan_dev) <a href="https://twitter.com/ncoghlan_dev/statuses/350971160659378176">June 29, 2013</a></blockquote>


<script async src="http://akaptur.github.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>Let&rsquo;s look at <a href="https://gist.github.com/ncoghlan/5891123#file-crazy-namespace-python-2">that gist</a>:</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>class Madness(dict):
&hellip;     def <strong>setitem</strong>(self, attr, value):
&hellip;         if isinstance(value, type):
&hellip;             value.<strong>name</strong> = attr
&hellip;         dict.<strong>setitem</strong>(self, attr, value)
&hellip;
code = &ldquo;&rdquo;&ldquo;\
&hellip; class Example(object): pass
&hellip; NewName = Example
&hellip; print(Example.<strong>name</strong>)
&hellip; &rdquo;&ldquo;&rdquo;
exec code in Madness()
NewName
```</p></blockquote></blockquote></blockquote>

<p>This is really fun stuff, and nicely illustrates a core feature of python &ndash; that namespaces are basically just dictionaries.</p>

<p>So what&rsquo;s going on here?  In this case, I think it&rsquo;s easiest to work backwards from the end.</p>

<p>Last we have <code>exec code in Madness()</code>. The <code>exec</code> keyword in python 2<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> executes a string as code.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>a = &ldquo;hello&rdquo;
exec &ldquo;print a&rdquo;
hello
```</p></blockquote></blockquote></blockquote>

<p><code>exec</code> optionally takes a context in which to execute the code.  A dictionary is a perfectly legal context to use:</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>exec &ldquo;print b&rdquo; in {&lsquo;b&rsquo; : &ldquo;hi there&rdquo;}
hi there
```</p></blockquote></blockquote></blockquote>

<p>All the code is shown here &ndash; <code>b</code> is not defined elsewhere in the REPL session.</p>

<p>If a dictionary is provided, it&rsquo;s presumed to contain both the global and the local variables.  This dictionary is the <strong>only</strong> context in which the code will be executed (it won&rsquo;t check the scope from which the <code>exec</code> statement was made).</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>a = &ldquo;hello&rdquo;
exec &ldquo;print a&rdquo; in {&lsquo;b&rsquo;: &ldquo;hi there&rdquo;}
Traceback (most recent call last):
  File &ldquo;<stdin>&rdquo;, line 1, in <module>
  File &ldquo;<string>&rdquo;, line 1, in <module>
NameError: name &lsquo;a&rsquo; is not defined
<code>``
So without knowing anything about the</code>Madness()` object, we&rsquo;d expect it to be a dictionary-like thing.</p></blockquote></blockquote></blockquote>

<p>And sure enough, it is:
``` python</p>

<blockquote><blockquote><blockquote><p>class Madness(dict):
&hellip;     def <strong>setitem</strong>(self, attr, value):
```</p></blockquote></blockquote></blockquote>

<p><code>__setitem__</code> is the standard way to override setting a key:value pair in a dictionary.  It works just like you&rsquo;d expect:
``` python</p>

<blockquote><blockquote><blockquote><p>d = {}
d.<strong>setitem</strong>(&lsquo;hello&rsquo;, 2)
d
{&lsquo;hello&rsquo;: 2}
```</p></blockquote></blockquote></blockquote>

<p>We&rsquo;re intercepting any attempt to write to the Madness dictionary-like object.
<code>python
...     def __setitem__(self, attr, value):
...         if isinstance(value, type):
...             value.__name__ = attr
...         dict.__setitem__(self, attr, value)
</code></p>

<p>If the value of the key:value pair that we&rsquo;re setting is an instance of the <code>type</code> type &ndash; that is, if the object in question is a class &ndash; then grab that class&rsquo;s <strong>name</strong> and set it to the key.  (This step will blow up if the key in question isn&rsquo;t a legal name in the first place.)  Then use the parent class (<code>dict</code>)&rsquo;s <code>__setitem__</code> to actually write to the Madness object.</p>

<p>We can execute the code string one line at a time to better see what&rsquo;s happening.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>m = Madness()
m.keys()
[]
exec &ldquo;class Example(object): pass&rdquo; in m
m.keys()
[&lsquo;<strong>builtins</strong>&rsquo;, &lsquo;Example&rsquo;]
m[&lsquo;Example&rsquo;]
<class 'Example'>
exec &ldquo;NewName = Example&rdquo; in m
m.keys()
[&lsquo;<strong>builtins</strong>&rsquo;, &lsquo;NewName&rsquo;, &lsquo;Example&rsquo;]
m[&lsquo;Example&rsquo;]
<class 'NewName'>
m[&lsquo;NewName&rsquo;]
<class 'NewName'
exec "OtherName = Example" in m
m['Example']
<class 'OtherName'>
```</p></blockquote></blockquote></blockquote>

<p>(I&rsquo;m using <code>m.keys()</code> to examine the state of the namespace instead of just printing <code>m</code> because the reference to <code>__builtins__</code> pukes a bunch of tiresome definitions and copyright statements into the REPL.  <code>exec</code> adds a reference to <code>__builtins__</code> on the execution of any statement.)</p>

<p>We&rsquo;re now quite close to the original Ruby behavior &ndash; with a deeper understanding of python namespaces!</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>All of this works in python 3, too, with slightly different syntax because <code>exec</code> is a function, not a keyword.  Nick&rsquo;s gist includes the python 3 version too.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Side-effecting Assignment]]></title>
    <link href="http://akaptur.github.com/blog/2013/06/28/side-effecting-assignment/"/>
    <updated>2013-06-28T14:35:00-04:00</updated>
    <id>http://akaptur.github.com/blog/2013/06/28/side-effecting-assignment</id>
    <content type="html"><![CDATA[<h2>Surprises</h2>

<p>My colleague <a href="https://github.com/davidbalbert">Dave</a> told me about an interesting bit of Ruby the other day.  If you make a new <code>Class</code> object, it initially has no name. If you then assign a name to it, with your new class on the right-hand side of the assignment, the name is attached to the Class object.</p>

<p><code>ruby
[1] pry(main)&gt; c = Class.new
=&gt; #&lt;Class:0x007ff19bc46988&gt;
[3] pry(main)&gt; c.name
=&gt; nil
[4] pry(main)&gt; Foo = c
=&gt; Foo
[5] pry(main)&gt; Foo
=&gt; Foo
[6] pry(main)&gt; c
=&gt; Foo
[7] pry(main)&gt; c.name
=&gt; "Foo"
</code></p>

<p>I found this shockingly non-intuitive. Really, an assignment statement permanently modified the object on the right-hand side?</p>

<p>In a word, yes.</p>

<p>``` ruby
[8] pry(main)> Bar = c
=> Foo
[9] pry(main)> c
=> Foo
[10] pry(main)> Foo
=> Foo
[11] pry(main)> Bar
=> Foo</p>

<p>[12] pry(main)> Baz = Foo
=> Foo
[13] pry(main)> Baz
=> Foo
```</p>

<p>To recap:</p>

<p>Step 1: <code>c</code> is some object</p>

<p>Step 2: set <code>Foo = c</code></p>

<p>Step 3: <code>c</code> is permanently altered.</p>

<p>Wow.</p>

<p>Luckily for our intuition, this is a pretty special case, and not a way that Ruby generally behaves.  But it got me wondering if there&rsquo;s something similar in python.</p>

<h2>What about python?</h2>

<p>The simplest answer is &ldquo;no&rdquo;.  In python, <a href="http://docs.python.org/2/reference/simple_stmts.html#assignment-statements">assignment is a simple statement</a>, not an operator, so you can&rsquo;t do things like operator overloading.  This also means we can&rsquo;t somehow add a hook to assignment.</p>

<p>Ok, fine.  But wait &ndash; we&rsquo;re programmers!  We don&rsquo;t give up that easily.</p>

<p>What about hooking on <code>__getattribute__</code>?  (Defining your own <code>__getattribute__</code> is &ldquo;the bad way&rdquo; to do it.  You almost always want to define your own <code>__getattr__</code>, unless you&rsquo;re doing something silly and/or malicious, like we are.  Note that we have to use the parent class (<code>object</code>)&rsquo;s <code>__getattribute__</code> to extract and save the attribute we want.  If we didn&rsquo;t do that, we&rsquo;d trigger an infinitely recursive lookup.)</p>

<p>``` python
class Foo(object):</p>

<pre><code>def __init__(self):
    self.some_attr = "sup foo"

def __getattribute__(self, attr):
    attribute = object.__getattribute__(self, attr)
    object.__setattr__(self, attr, "you're too late!")
    return attribute
</code></pre>

<p>```</p>

<p>This looks like it works!</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>f = Foo()
f
&lt;obj.Foo object at 0x10253dd10>
word = f.some_attr
print word
sup foo
print f.some_attr
you&rsquo;re too late!
```</p></blockquote></blockquote></blockquote>

<p>Unfortunately, this behavior has nothing to do with assignment.  The object was mutated when <code>__getattribute__</code> was called, which happened to be in an assignment statement in this code above.  We&rsquo;d get exactly the same behavior without the assignment:</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>g = Foo()
g
&lt;obj.Foo object at 0x10253dd10>
g.some_attr
sup foo
g.some_attr
you&rsquo;re too late!
```</p></blockquote></blockquote></blockquote>

<p>Darn.</p>

<p>But we&rsquo;re programmers, right?  We don&rsquo;t give up that easily.</p>

<h2>Trace functions to the rescue</h2>

<p>There&rsquo;s a <code>settrace</code> function in python&rsquo;s <code>sys</code> module that we can use to examine stack frames, events, and lots of other code data while our program is running.  <code>sys.settrace(fn)</code> takes a trace function as an argument, and that trace function must take <code>frame, event, args</code> as arguments.  It will then get called every time an event happens.  A line of code, a function call, a function return, and an exception are all &ldquo;events&rdquo;.  We can use this to inspect each line of code before it runs and check manually if it&rsquo;s an assignment statement.</p>

<p>(I know this is silly, but isn&rsquo;t it fun?)</p>

<p>``` python
import linecache</p>

<p>class Tracer(object):</p>

<pre><code>def __init__(self, program):
    self.program = program

def traceit(self, frame, event, arg):
    if event == 'line':
        linenum = frame.f_lineno
        linetext = linecache.getline(self.program, linenum)
        vprint( 'line', linenum, linetext )

        is_assignment = "=" in linetext and "==" not in linetext

        if is_assignment:
            self.mess_up_on_assignment(frame, linetext)

    return self.traceit
</code></pre>

<p>```</p>

<p>(The trace function returns a reference to itself to indicate that tracing should continue.)</p>

<p>Now let&rsquo;s write our code to mess up assignment.</p>

<p>``` python
class Tracer(object):</p>

<pre><code>[...]

def mess_up_on_assignment(self, frame, linetext):
    rhs = linetext[linetext.index("=")+1:]
    names = rhs.split()
    local_objs = [name for name in names if name in frame.f_locals.keys() + frame.f_globals.keys()]
    for name in local_objs:
        if name not in JANKY_NAMESPACE_MANAGER:
            box = Box(frame.f_locals[name], name)
            frame.f_locals[name] = box
        else:
            JANKY_NAMESPACE_MANAGER[name].assignments += 1
</code></pre>

<p>JANKY_NAMESPACE_MANAGER = {}</p>

<p>class Box(object):</p>

<pre><code>def __init__(self, obj, name):
    self.obj = obj
    self.name = name
    self.assignments = 1
    JANKY_NAMESPACE_MANAGER[name] = self

def __repr__(self):
    raise NameError("this message has self-destructed.")
</code></pre>

<p>```</p>

<p>Here our &ldquo;box&rdquo; object is pretty silly.  It takes the original object and wraps it in a box.  (You could implement <code>__getattr__</code> and <code>__setattr__</code> so that the box behaves basically like the original object, which I haven&rsquo;t done.)  The box then explodes when you try to print it.  We&rsquo;re also tracking which names we&rsquo;ve seen with the aptly-named <code>JANKY_NAMESPACE_MANAGER</code> (which has all kinds of scope issues, but whatever).</p>

<p>Meanwhile, in the <code>mess_up_on_assignment</code> code, we check to see if any of the whitespace-separated words on the right-hand side of the equation are names we recognize from <code>frame.f_locals</code> or <code>frame.f_globals</code>.  If so, and if we haven&rsquo;t seen them before, throw them in a self-destructing box!</p>

<p>Add a simple helper to get things set up.</p>

<p>``` python
def assignment(orig_file):</p>

<pre><code>trace_obj = Tracer(orig_file)
sys.settrace(trace_obj.traceit)
</code></pre>

<p>```</p>

<p>We can now sabotage simple-looking programs!</p>

<p>This one runs fine:
``` python
import sabotage
sabotage.assignment(<strong>file</strong>)</p>

<p>def greet():</p>

<pre><code>name = raw_input("Enter your name: ")
print "hello,", name

print "goodbye, ", name
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>greet()
</code></pre>

<p>```</p>

<p>And this one blows up:
``` python
import sabotage
sabotage.assignment(<strong>file</strong>)</p>

<p>print &ldquo;done sabotaging&rdquo;
raw_input(&ldquo;Hit enter to continue&rdquo;)</p>

<p>def greet():</p>

<pre><code>name = raw_input("Enter your name: ")
print "hello,", name

name_copy = name

print "goodbye, ", name
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>greet()
</code></pre>

<p>```</p>

<p>And there you have it &ndash; a (incredibly goofy) side-effecting assignment that mutates the object on the right-hand side of the assignment statement.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Surprised by Stable Sort]]></title>
    <link href="http://akaptur.github.com/blog/2013/01/02/surprised-by-stable-sort/"/>
    <updated>2013-01-02T00:02:00-05:00</updated>
    <id>http://akaptur.github.com/blog/2013/01/02/surprised-by-stable-sort</id>
    <content type="html"><![CDATA[<p>I encountered some surprising behavior in python&rsquo;s list.sort() method.  I was calling list.sort() with a function, then list.reverse().  This was silly &ndash; I forgot I could call list.sort(reverse=True).  As it turns out, these are not the always the same, or even usually the same.</p>

<p>Here&rsquo;s the code:</p>

<p>```
def two_sort(ex):</p>

<pre><code>ex_copy = ex[:]

ex.sort(key=lambda tup: tup[1])
ex.reverse()
print "Ex:  ", ex

ex_copy.sort(key=lambda tup: tup[1], reverse=True)
print "Copy:", ex_copy

assert ex == ex_copy # fails
</code></pre>

<p>ex = [(&lsquo;a&rsquo;, 0), (&lsquo;b&rsquo;, 0), (&lsquo;c&rsquo;, 2), (&rsquo;d', 3)]
two_sort(ex)</p>

<h1>Ex:   [(&rsquo;d', 3), (&lsquo;c&rsquo;, 2), (&lsquo;b&rsquo;, 0), (&lsquo;a&rsquo;, 0)]</h1>

<h1>Copy: [(&rsquo;d', 3), (&lsquo;c&rsquo;, 2), (&lsquo;a&rsquo;, 0), (&lsquo;b&rsquo;, 0)]</h1>

<p>```</p>

<p>What&rsquo;s happening here is that .sort() and sorted() in python are &ldquo;stable sorts&rdquo;, meaning that it&rsquo;ll preserve the existing order when faced with a tie.  This leads to a nice side effect, as described in the <a href="http://wiki.python.org/moin/HowTo/Sorting/">python wiki</a>: you can sort by multiple criteria.  So if we wanted to sort primarily by number (ascending), and secondarily by letter, we could do that quite easily.  Just sort by the secondary key first, then by the primary key.  Since the sort is stable, you know that a tie in the second (primary) sort will preserve the order you had going in.</p>

<p>```</p>

<blockquote><blockquote><blockquote><p>a = [(&rsquo;d', 3), (&lsquo;c&rsquo;, 5), (&lsquo;b&rsquo;, 0), (&lsquo;a&rsquo;, 0)]
a.sort(key=lambda tup: tup[0])
a
[(&lsquo;a&rsquo;, 0), (&lsquo;b&rsquo;, 0), (&lsquo;c&rsquo;, 5), (&rsquo;d', 3)]
a.sort(key=lambda tup:tup[1])
a
[(&lsquo;a&rsquo;, 0), (&lsquo;b&rsquo;, 0), (&rsquo;d', 3), (&lsquo;c&rsquo;, 5)]
```</p></blockquote></blockquote></blockquote>
]]></content>
  </entry>
  
</feed>
